package eu.chorevolution.vsb.gm.protocols.soap;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import com.sun.codemodel.JAnnotationUse;
import com.sun.codemodel.JBlock;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JFieldVar;
import com.sun.codemodel.JInvocation;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JVar;
import com.sun.codemodel.writer.SingleStreamCodeWriter;

import eu.chorevolution.vsb.gm.protocols.builders.ResponseBuilder;
import eu.chorevolution.vsb.gm.protocols.generators.BcComponentGenerator;
import eu.chorevolution.vsb.gm.protocols.primitives.BcGmComponent;
import eu.chorevolution.vsb.gmdl.utils.BcConfiguration;
import eu.chorevolution.vsb.gmdl.utils.Data;
import eu.chorevolution.vsb.gmdl.utils.GmComponentRepresentation;
import eu.chorevolution.vsb.gmdl.utils.Operation;
import eu.chorevolution.vsb.gmdl.utils.enums.OperationType;

// TODO: refactor, clean & clear as much as possible...
public class BcSoapGenerator extends BcComponentGenerator {
	private final String classComment = "This class was generated by the CHOReVOLUTION BindingComponent Generator using com.sun.codemodel 2.6";

	public BcSoapGenerator(GmComponentRepresentation componentDescription, BcConfiguration bcConfiguration) {
		super(componentDescription, bcConfiguration);
	}

	@Override
	protected void generatePojo(final Data<?> definition) {
		JCodeModel codeModel = new JCodeModel();
		JDefinedClass definitionClass = this.generateDefinedClass(codeModel, definition.getClassName());
		this.addComment(definitionClass, this.classComment);

		definitionClass.annotate(javax.xml.bind.annotation.XmlAccessorType.class).param("value", javax.xml.bind.annotation.XmlAccessType.FIELD);

		definitionClass.annotate(javax.xml.bind.annotation.XmlRootElement.class).param("name", definition.getClassName());

		// generate attributes and corresponding accessors
		for (Data<?> attr : definition.getAttributes()) {
			JFieldVar attrField = generateAttribute(codeModel, definitionClass, codeModel.directClass(attr.getClassName()), attr.getName(), false);
			JAnnotationUse attrAnnotation = attrField.annotate(codeModel.ref("javax.xml.bind.annotation.XmlElement"));
			attrAnnotation.param("name", attr.getName());
			attrAnnotation.param("required", attr.isRequired());

			// generate getters
			definitionClass.method(JMod.PUBLIC, attrField.type(), "get" + attr.getName()).body()._return(attrField);

			// generate setters
			JMethod setterMethod = definitionClass.method(JMod.PUBLIC, codeModel.VOID, "set" + attr.getName());
			setterMethod.param(attrField.type(), attr.getName());
			setterMethod.body().assign(JExpr._this().ref(attr.getName()), JExpr.ref(attr.getName()));

			// if complex type, generate its definition
			if (!attr.isPrimitiveType()) {
				this.generatePojo(attr);
			}
		}

		this.buildGeneratedClass(codeModel);
	}

	@Override
	protected void generateEndpoint() {
		JCodeModel codeModel = new JCodeModel();
		JDefinedClass webService = generateDefinedClass(codeModel, this.bcConfiguration.getServiceName());

		this.addComment(webService, this.classComment);
		this.addAnnotations(codeModel, webService, "javax.jws.WebService");

		JClass apiClass = codeModel.ref(BcGmComponent.class);
		JFieldVar apiField = generateAttribute(codeModel, webService, apiClass, "apiRef", true);

		JMethod constructor = webService.constructor(JMod.PUBLIC);
		constructor.param(apiClass, "apiRef");
		constructor.body().assign(JExpr._this().ref(apiField), apiField);

		Collection<Operation> operations = this.componentDescription.getOperations();
		for (Operation operation : operations) {
			this.buildOperation(operation, webService, codeModel);
		}

		this.buildGeneratedClass(codeModel);
	}

	private JDefinedClass generateDefinedClass(final JCodeModel codeModel, final String className) {
		JDefinedClass definedClass = null;
		try {
			definedClass = codeModel._class(this.bcConfiguration.getTargetNamespace() + "." + className);
		} catch (JClassAlreadyExistsException e) {
			e.printStackTrace();
		}
		return definedClass;
	}

	private void addAnnotations(final JCodeModel codeModel, final JDefinedClass definedClass, final String annotationClassRef) {
		JAnnotationUse webServiceAnnotation = definedClass.annotate(codeModel.ref(annotationClassRef));
		webServiceAnnotation.param("serviceName", bcConfiguration.getServiceName());
		webServiceAnnotation.param("targetNamespace", bcConfiguration.getTargetNamespace());
	}

	private JFieldVar generateAttribute(final JCodeModel codeModel, final JDefinedClass definedClass, final Class<?> attrClass,
			final String attrName, final Boolean isFinal) {
		return this.generateAttribute(codeModel, definedClass, codeModel.ref(attrClass), attrName, isFinal);
	}

	private JFieldVar generateAttribute(final JCodeModel codeModel, final JDefinedClass definedClass, final JClass attrClass,
			final String attrName, final Boolean isFinal) {
		JFieldVar attrField = definedClass.field(JMod.PRIVATE, attrClass, attrName);
		attrField.mods().setFinal(isFinal);
		return attrField;
	}

	private void addComment(final JDefinedClass definedClass, final String comment) {
		definedClass.javadoc().add(comment);
	}

	private void buildGeneratedClass(final JCodeModel codeModel) {
		// TESTING PURPOSE
		// Write the generated class to the console output
		if (debug) {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			try {
				codeModel.build(new SingleStreamCodeWriter(out));
			} catch (IOException e) {
				e.printStackTrace();
			}
			System.out.println(out);
		}

		try {
			codeModel.build(new File(this.bcConfiguration.getGeneratedCodePath()));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void buildOperation(final Operation operation, final JDefinedClass definedClass, final JCodeModel codeModel) {
		JMethod method = null;
		if (operation.getPostData() == null) {
			method = definedClass.method(JMod.PUBLIC, void.class, operation.getScope().getName());
		} else {
			method = definedClass.method(JMod.PUBLIC, codeModel.directClass(operation.getPostData().getClassName()), operation.getScope()
					.getName());
		}

		JBlock methodBlock = method.body();

		method.annotate(codeModel.ref("javax.jws.WebMethod"));

		JClass dataClass = codeModel.ref(List.class).narrow(codeModel.ref(Data.class).narrow(codeModel.wildcard()));
		JVar dataList = methodBlock.decl(dataClass, "datas");
		dataList.init(JExpr._new(codeModel.ref(ArrayList.class).narrow(codeModel.ref(Data.class).narrow(codeModel.wildcard()))));

		this.wrapOperationParams(method, codeModel, operation.getGetDatas(), dataList);

		JInvocation gmInvocation = this.generateGmInvokation(operation, definedClass).arg(dataList);

		if (operation.getOperationType() == OperationType.ONE_WAY) {
			methodBlock.add(gmInvocation);
		} else {
			// unmarshal the serialized object
			JClass stringClass = codeModel.ref(String.class);
			JVar serializedResponse = methodBlock.decl(stringClass, "serialized" + operation.getPostData().getName());
			serializedResponse.init(gmInvocation);

			JInvocation responseBuilderInvocation = codeModel.ref(ResponseBuilder.class).staticInvoke("unmarshalObject")
					.arg(operation.getPostData().getMediaTypeAsString()).arg(serializedResponse)
					.arg(codeModel.directClass(operation.getPostData().getClassName()).dotclass());

			methodBlock._return(responseBuilderInvocation);
		}
	}

	private JInvocation generateGmInvokation(Operation operation, JDefinedClass definedClass) {
		JInvocation apiInvocation = null;
		switch (operation.getOperationType()) {
		case ONE_WAY:
			// TODO logs
			apiInvocation = JExpr._this().ref(definedClass.fields().get("apiRef")).invoke("mgetOneway").arg(operation.getScope().getUri());
			break;
		case TWO_WAY_SYNC:
			apiInvocation = JExpr._this().ref(definedClass.fields().get("apiRef")).invoke("mgetTwowaySync").arg(operation.getScope().getUri());
			break;
		case TWO_WAY_ASYNC:
			apiInvocation = JExpr._this().ref(definedClass.fields().get("apiRef")).invoke("mgetTwowayAsync").arg(operation.getScope().getUri());
			break;
		case STREAM:
			throw new UnsupportedOperationException();
		default:
			throw new UnsupportedOperationException();
		}
		return apiInvocation;
	}

	private void wrapOperationParams(JMethod method, JCodeModel codeModel, List<Data<?>> getDatas, JVar dataList) {
		JInvocation dataCreation = null;
		for (Data<?> data : getDatas) {
			method.param(codeModel.directClass(data.getClassName()), data.getName());

			dataCreation = JExpr._new(codeModel.ref(Data.class).narrow(codeModel.directClass(data.getClassName())));
			dataCreation.arg(data.getName()).arg(data.getClassName()).arg(JExpr.lit(data.isPrimitiveType())).arg(JExpr.ref(data.getName()))
					.arg(JExpr.lit(data.getContext().toString()));
			JInvocation addData2List = dataList.invoke("add").arg(dataCreation);
			method.body().add(addData2List);
		}
	}
}